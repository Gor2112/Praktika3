# Алгоритмы сортировки и поиска: 
## Сортировка выбором
Основная концепция: Поэтапный поиск минимального элемента с последующим перемещением его в начало неотсортированного сегмента.

Процесс выполнения:

Разделяем массив на отсортированную и неотсортированную области

На каждом этапе находим наименьший элемент в неотсортированной части

Обмениваем его с первым элементом неотсортированного сегмента

Расширяем отсортированную область на один элемент

Продолжаем до полной сортировки

Производительность: Временная сложность O(n²) для всех случаев

Пример:

Исходные данные: [64, 25, 12, 22, 11]
Шаг 1: [11, 25, 12, 22, 64]
Шаг 2: [11, 12, 25, 22, 64]
Шаг 3: [11, 12, 22, 25, 64]
## Пузырьковая сортировка
Основная концепция: Многократное сравнение и обмен соседних элементов, при котором наибольшие значения "всплывают" к концу массива.

Процесс выполнения:

Последовательно сравниваем соседние элементы

При нарушении порядка выполняем обмен

После каждого прохода наибольший элемент занимает свою конечную позицию

Повторяем процесс для уменьшенной области массива

Завершаем при отсутствии обменов за полный проход

Производительность:

Оптимальный случай: O(n)

Средний и наихудший случаи: O(n²)

Пример:
Исходный массив: [5, 1, 4, 2, 8]
Обмен: 1 <-> 5: [1, 5, 4, 2, 8]
Обмен: 2 <-> 5: [1, 4, 2, 5, 8]
Обмен: 2 <-> 4: [1, 2, 4, 5, 8]

## Сортировка вставками
Основная концепция: Постепенное построение отсортированной последовательности путем вставки каждого нового элемента в правильную позицию.

Процесс выполнения:

Начинаем со второго элемента как вставляемого значения

Сравниваем с элементами отсортированной части справа налево

Сдвигаем элементы, превышающие вставляемое значение

Вставляем элемент на найденную позицию

Повторяем для всех последующих элементов

Производительность:

Оптимальный случай: O(n)
Средний и наихудший случаи: O(n²)

Пример:
Исходный массив: [12, 11, 13, 5, 6]
Сдвиг: [12, 12, 13, 5, 6]
Вставка 11: [11, 12, 13, 5, 6]
Вставка 13: [11, 12, 13, 5, 6]
Сдвиг: [11, 12, 13, 13, 6]
Сдвиг: [11, 12, 12, 13, 6]
Сдвиг: [11, 11, 12, 13, 6]
Вставка 5: [5, 11, 12, 13, 6]
Сдвиг: [5, 11, 12, 13, 13]
Сдвиг: [5, 11, 12, 12, 13]
Сдвиг: [5, 11, 11, 12, 13]
Вставка 6: [5, 6, 11, 12, 13]

## Сортировка слиянием
Основная концепция: Рекурсивное разделение массива на меньшие части с последующим объединением упорядоченных фрагментов.

Процесс выполнения:

Рекурсивно делим массив пополам до получения единичных элементов

Объединяем отсортированные пары в упорядоченные последовательности

Повторяем слияние до получения полного отсортированного массива

Производительность: O(n log n) для всех случаев

Пример:
Исходный массив: [38, 27, 43, 3, 9, 82, 10]
Разделение: [38, 27, 43] | [3, 9, 82, 10]
Разделение: [38] | [27, 43]
Разделение: [27] | [43]
Слияние: [27, 43]
Слияние: [27, 38, 43]
Разделение: [3, 9] | [82, 10]
Разделение: [3] | [9]
Слияние: [3, 9]
Разделение: [82] | [10]
Слияние: [10, 82]
Слияние: [3, 9, 10, 82]
Слияние: [3, 9, 10, 27, 38, 43, 82]

## Сортировка Шелла
Основная концепция: Усовершенствованный вариант сортировки вставками с использованием убывающих интервалов.

Процесс выполнения:

Выбираем начальный шаг сравнения (gap)

Сортируем элементы, отстоящие на расстоянии gap

Постепенно уменьшаем шаг до 1

Завершаем обычной сортировкой вставками

Производительность: Зависит от выбора последовательности шагов (от O(n log n) до O(n²))

Пример:
Исходный: [23, 12, 1, 8, 34, 54, 2, 3]
Результат: [1, 2, 3, 8, 12, 23, 34, 54]

## Быстрая сортировка
Основная концепция: Эффективный алгоритм, основанный на стратегии "разделяй и властвуй" с выбором опорного элемента.

Процесс выполнения:

Выбираем опорный элемент

Перераспределяем элементы: меньшие слева, большие справа

Рекурсивно применяем алгоритм к полученным частям

Объединяем результаты

Производительность:

Оптимальный и средний случаи: O(n log n)

Наихудший случай: O(n²)

Пример:
Исходный массив: [10, 7, 8, 9, 1, 5]
Опорный элемент 5 на позиции 0: [1, 5, 8, 9, 10, 7]
Опорный элемент 1 на позиции 0: [1]
Опорный элемент 9 на позиции 3: [8, 7, 9, 10]
Опорный элемент 7 на позиции 2: [7, 8]
Отсортированный массив: [1, 5, 7, 8, 9, 10]

## Пирамидальная сортировка
Основная концепция: Использование структуры данных "куча" для эффективного извлечения максимальных элементов.

Процесс выполнения:

Преобразуем массив в max-кучу

Последовательно извлекаем максимальный элемент в конец массива

Восстанавливаем свойства кучи после каждого извлечения

Повторяем до полной сортировки

Производительность: O(n log n) для всех случаев

Пример:
Исходный массив: [4, 10, 3, 5, 1]
Построена куча: [10, 5, 3, 4, 1]
Извлечен 10: [5, 4, 3, 1] | [10]
Извлечен 5: [4, 1, 3] | [5, 10]
Извлечен 4: [3, 1] | [4, 5, 10]
Извлечен 3: [1] | [3, 4, 5, 10]
Отсортированный массив: [1, 3, 4, 5, 10]

## Алгоритмы поиска
Линейный поиск
Основная концепция: Последовательная проверка каждого элемента массива.

Процесс выполнения:

Начинаем с первого элемента

Сравниваем текущий элемент с искомым значением

При совпадении возвращаем индекс

При несовпадении переходим к следующему элементу

При достижении конца массива без результата возвращаем -1

Производительность: O(n)

Пример:
Поиск 7 в [3, 5, 2, 7, 9, 1, 4]
Проверка позиции 0: 3
Проверка позиции 1: 5
Проверка позиции 2: 2
Проверка позиции 3: 7
✓ Найдено на позиции 3

## Бинарный поиск
Основная концепция: Эффективный поиск в отсортированном массиве путем деления области поиска пополам.

Процесс выполнения:

Определяем начальные границы поиска

Вычисляем средний элемент

Сравниваем с искомым значением

Сужаем область поиска в соответствующую половину

Повторяем до нахождения элемента или пустой области

Производительность: O(log n)

Пример:
Шаг 1: low=0, high=9, mid=4, arr[mid]=9
Ищем слева: high=3
Шаг 2: low=0, high=3, mid=1, arr[mid]=3
Ищем справа: low=2
Шаг 3: low=2, high=3, mid=2, arr[mid]=5
Ищем справа: low=3
Шаг 4: low=3, high=3, mid=3, arr[mid]=7
✓ Найдено на позиции 3

## Интерполяционный поиск
Основная концепция: Улучшенный бинарный поиск для равномерно распределенных данных с предсказанием позиции.

Процесс выполнения:

Вычисляем предполагаемую позицию на основе значений границ

Сравниваем элемент в вычисленной позиции с искомым

Корректируем границы поиска на основе сравнения

Повторяем до нахождения элемента

Производительность:

Оптимальный случай: O(1)

Средний случай: O(log log n)

Наихудший случай: O(n)

Пример:
Шаг 1: low=0, high=9, pos=5, arr[pos]=60
✓ Найдено на позиции 5

## Поиск Фибоначчи
Основная концепция: Алгоритм поиска, использующий числа Фибоначчи для деления массива.

Процесс выполнения:

Находим подходящее число Фибоначчи

Используем числа Фибоначчи для определения позиций сравнения

Корректируем область поиска на основе сравнения

Повторяем до нахождения элемента

Производительность: O(log n)

Пример:
Шаг 1: fib_m=13, fib_m2=5, offset=-1, i=4, arr[i]=45
Ищем справа: offset=4
Шаг 2: fib_m=8, fib_m2=3, offset=4, i=7, arr[i]=82
Ищем справа: offset=7
Шаг 3: fib_m=5, fib_m2=2, offset=7, i=9, arr[i]=90
Ищем слева
Шаг 4: fib_m=2, fib_m2=1, offset=7, i=8, arr[i]=85
✓ Найдено на позиции 8
