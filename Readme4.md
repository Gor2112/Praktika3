Вариант 5  
"Напишите рекурсивную функцию для проверки, является ли строка палиндромом.":

Алгоритм проверки палиндрома (рекурсивный) в Python

Шаг 1 — Проверяем, прошли ли мы всю строку

Если указатели пересеклись или встретились → все пары совпали → палиндром

if left >= right:
    return True

Это и есть базовый случай рекурсии (остановка).


Шаг 2 — Сравниваем символы на концах строки

Если символы отличаются → это точно не палиндром 

if s[left] != s[right]:
    return False


Шаг 3 — Движение внутрь строки

Если пара совпала → продолжаем проверку рекурсивно

return is_palindrome(s, left + 1, right - 1)

В каждом рекурсивном вызове проблема уменьшается → остаётся меньшая строка.


Шаг 4 — Запуск алгоритма

Стартуем с крайних символов

is_palindrome(s, 0, len(s)-1)

 Временная сложность 

O(n) — линейная.

 Объяснение временной сложности

На каждом шаге рекурсии:

 Выполняется одно сравнение символов
Уменьшается длина рассматриваемой части строки на 2 символа

Количество шагов ~ n/2 → упрощаем до O(n).

Ответ на вопрос 6:
 В чём суть алгоритма backtracking?

Backtracking (поиск с возвратом) — это метод перебора, когда:
 1. Пробуем сделать выбор
 2. Рекурсивно двигаемся дальше
 3. Если путь оказался неверным → возвращаемся назад (откат)
 4. Пробуем следующий вариант

Используется в задачах перебора вариантов:
 • задачи о размещениях (N-ферзей)
 • генерация всех комбинаций/перестановок
 • поиск в лабиринте
 • Sudoku
